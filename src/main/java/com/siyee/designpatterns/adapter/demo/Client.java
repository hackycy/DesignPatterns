package com.siyee.designpatterns.adapter.demo;

public class Client {

    public static void main(String[] args) {

        /**
         * 适配器模式
         * 优点：
         * 1、将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无需修改原有结构。
         * 2、增加了类的透明性和复用性，将具体的业务实现过程分装在适配者类中，对于客户端类而言是透明的，而且提高了新的适配者得复用性，同一个
         *    适配者类可以在多个不同的系统中复用。
         * 3、灵活性和扩展性都非常好，通过使用配置文件可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，符合开闭原则。
         *
         * 类适配器还有以下优点：
         * 1、由于适配器类是适配者类地子类，因此可以在适配类中置换一些适配者地方法，使得适配器的灵活性更强。
         *
         * 对象适配器还有以下优点：
         * 1、一个对象适配器可以把多个不同地适配者适配到同一个目标。
         * 2、可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据里氏替换原则，适配者的子类也可以通过该适配器进行适配。
         *
         * 类适配器缺点：
         * 1、对于Java、C#等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者。
         * 2、适配者类不能为最终类，例如Java中不能为final类
         * 3、在Java、C#等语言中，类适配器模式的目标抽象类只能为接口，不能为类，其使用有一定的局限性。
         *
         * 对象适配器缺点：
         * 1、在类适配器模式相比，在该模式下要在适配器中替换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个
         *    适配者类的子类，将适配者类的方法之换掉，然后再把适配者类的子类当成真正的适配者进行适配，实现过程较为复杂。
         *
         * 适用环境：
         * 1、系统需要使用一些现有的类，而这些类的接口（例如方法名）不符合系统的需要，甚至没有这些类的源代码。
         * 2、想创建一个可以重复使用的类，用于和一些彼此之间没有太大关联的类（包括一些可能在将来引进的类）一起工作。
         */
        CarController controller = new PoliceCarAdpater();
        controller.move();
        controller.phonate();
        controller.twinkle();
    }

}
