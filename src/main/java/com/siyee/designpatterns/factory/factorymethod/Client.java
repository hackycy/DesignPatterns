package com.siyee.designpatterns.factory.factorymethod;

public class Client {

    public static void main(String[] args) {
//        LoggerFactory f;
//        f = new DataBaseLoggerFactory();
//        Logger l;
//        l = f.createLogger();
//        l.writeLog();

        // Advance
        /**
         * 工厂方法模式
         * 优点：
         * 1、在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化的细节。
         * 2、基于工厂角色和产品角色的多态性是工厂方法模式的关键。它能够让工厂自主确定创建何种产品对象，而如何
         *    创建这个对象的细节完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，正是因为所有的具体工厂类都具有统一抽象父类。
         * 3、使用工厂方法模式的另一个优点实在系统中加入新产品无需修改抽象工厂和抽象产品提供的接口，甚至无需修改客户端，也无需修改其他的具体工厂，
         *    和具体产品，而只要添加一个具体工厂和具体产品即可，这样系统的可扩展性也就变得非常好，完全符合开闭原则。
         * 缺点：
         * 1、在添加新产品时需要编写新的具体产品类，而且还要提供与之对应的具体工厂类。系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有
         *    更多的类需要编译和运行，也给系统带来一些额外的开销。
         * 2、由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层定义，增加了系统的抽象性和理解难度。
         * 适用环境：
         * 1、客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体的产品类的类名，只需要知道所对应的工厂即可，具体产品对象由
         *    具体工厂类创建，可将具体工厂类的类名存储在配置文件中或数据库中。
         * 2、抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的
         *    多态性和里氏替换原则，在程序运行时子类对象将覆盖父类对象，从而使得系统更容易扩展。
         */

        LoggerFactoryAdv f;
//        f = new DataBaseLoggerFactoryAdv();
        f = new FileLoggerFactoryAdv();
        f.writeLog();
    }

}
